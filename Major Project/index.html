<!DOCTYPE HTML>

<head>
	<title>Mars Scene in WebGL</title>
	<link rel="stylesheet" href="code/css/gui.css">
	<link rel="stylesheet" href="libraries/jquery-ui-1.12.1.custom/jquery-ui.css">
	
	<!-- Libraries -->
	<script src="libraries/jquery-ui-1.12.1.custom/external/jquery/jquery.js"></script>
	<script src="libraries/jquery-ui-1.12.1.custom/jquery-ui.js"></script>
	<script src="libraries/m4.js"></script>
	<script src="libraries/ImprovedNoise.js"></script>
	<script src="libraries/webgl-obj-loader.js"></script>
	<script src="libraries/twgl-full.min.js"></script>
	<script src="libraries/dat.gui.min.js"></script>
	<script src="libraries/stats.min.js"></script>
</head>

<body>

<!-- GL Canvas -->
<canvas id="canvas"></canvas>
<!-- GUI compass canvas -->
<canvas id="GUIcanvas"></canvas>

<div id="outOfBoundsID" style="visibility: hidden">ALERT - Terrain too dangerous!</div>

<!-- WebGL setup files including main shaders and program -->
<script src="code/myJs/GLSetup.js"></script>
<script src="code/myJs/TextureLoader.js"></script>
<script src="code/myJs/Texture.js"></script>
<script src="code/myJs/VertexShader.js"></script>
<script src="code/myJs/FragmentShader.js"></script>
<script src="code/myJs/Program.js"></script>

<!-- Project files -->
<script src="code/myJs/CollisionTester.js"></script>
<script src="code/myJs/Terrain.js"></script>
<script src="code/myJs/RockGenerator.js"></script>
<script src="code/myJs/PointerLockControls.js"></script>
<script src="code/myJs/ParticleSystem.js"></script>
<script src="code/myJs/WaterSystem.js"></script>
<script src="code/myJs/Sound.js"></script>
<script src="code/myJs/Utility.js"></script>
<script src="code/myJs/Skybox.js"></script>
<script src="code/myJs/Camera.js"></script>
<script src="code/myJs/MyGUI.js"></script>

<script>

var useTests = true; // change this to enable/disable testing

var gameRunning = false;
var perlin = new ImprovedNoise();

var myGUI = new MyGUI();

var utility = new Utility();
var controls = new PointerLockControls();

var textureLoader = new TextureLoader();

var terrain = new Terrain();
var camera = new Camera();
var rockGenerator = new RockGenerator();

var collisionTester = new CollisionTester();
var particleSystem = new ParticleSystem();

var sound = new Sound();

var waterSystem = new WaterSystem();
var skybox = new Skybox();

/*
For FPS and memory, the library:
https://github.com/mrdoob/stats.js/

You can click on the FPS counter to change its setting
*/
var fpsViewer = new Stats();
fpsViewer.showPanel( 0 ); // 0: fps
document.body.appendChild( fpsViewer.dom );

var animationFrameID;
 
function render(){
	fpsViewer.begin();

	// Work out what quadrant we're in, so we know what to render
	camera.assignCameraQuadrant();

	// Render the entire scene to each the reflection and refraction textures
	// (2x FULL scene render calls)
	waterSystem.renderToReflectionBuffer();
	waterSystem.renderToRefractionBuffer();
	
	//Now render the scene as usual
	//We've already switched back to the default frame buffer
	gl.clearColor(0.8, 0.8, 0.8, 0.7);
	gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
	// Cant disable clipPlane on some drivers, just set to 0
	clipPlane = [0, 0, 0, 0];
	
	camera.updateCamera();

	//Don't change render order
	//terrain render generates the renderIndices, 
	//that are needed for rock rendering
	//The skybox has to render last, or everything breaks
	terrain.render(); 
	rockGenerator.renderInstancedRocks();
	
	//particleSystem.render(); 
	collisionTester.testAllCollision();
	
	waterSystem.render();
	skybox.render(viewMatrix, projectionMatrix);

	renderMinimap();
	fpsViewer.end();
	animationFrameID = requestAnimationFrame(render);
}

function setup(){
	gameRunning = true;	

	currentTexture = mapTexture;
	updateAttributesAndUniforms();
	camera.updateCamera();

	render();
}

/*
The problem is its based on top left of blue rectangle or something
	Would work if it was a small point
	
	The coordinates are mapped, now just add collision as usual,
	copy from terrain code
*/
var canvas_width = 58; // the CSS makes canvas way too big, the canvas is just blank so cant see it
var canvas_height = 58; // it looks smaller, cos only rendering a square to 50,50 - so set these as the height

// Map the map size to the width of the canvas
// Max map size = the actual size, or the accessible size, so -256 each
var gui_canvas_min = 0;
var gui_canvas_max = canvas_width;

var map_min = 0;
var map_max = terrain.get.getTerrainRows;

/*
Example for 4x4 map
	getTerrainRows = 512;
	getNumberQuadrantRows = 4;
	
	So the boundary value = 512/4 = 128

It will always be 128 with the formula!

Now need to map it to canvas size
*/
var canvas_boundary_unmapped = terrain.get.getTerrainRows / terrain.get.getNumberQuadrantRows;
console.log("canvas_boundary_unmapped: " + canvas_boundary_unmapped);
var canvas_boundary_mapped = (canvas_boundary_unmapped - 0) / (terrain.get.getTerrainRows - 0) * (gui_canvas_max - gui_canvas_min) + gui_canvas_min;
console.log("canvas_boundary_mapped: " + canvas_boundary_mapped);

function renderMinimap(){



	var canvasX = (camera.get.x - map_min) / (map_max - map_min) * (gui_canvas_max - gui_canvas_min) + gui_canvas_min;
	var canvasZ = (camera.get.z - map_min) / (map_max - map_min) * (gui_canvas_max - gui_canvas_min) + gui_canvas_min;

	// Only need to check right and bottom side !! 
	// the regular collsion stops it going off left/top and it looks correct, due to top left
	if(canvasX > gui_canvas_max - canvas_boundary_mapped - 3){
		canvasX -= 1;
		console.log("ya");
	}
	
	// Player on minimap has width and height of 5
	// Its mapped to 0->50
	// So, its always 128, which is getTerrainRows/numberQuadrants or something
	// so use getTerrainRows/numberQuadrants to work out 0->50 boundaries? 
	//just need it once

	
	//gui_context.fillStyle = 'rgb(0,0,0)'; // Black background
	gui_context.clearRect(0, 0, canvas_width, canvas_height); // Fills background
	gui_context.fillStyle = 'rgb(0,0,255)'; // Blue square
	gui_context.fillRect(canvasX, canvasZ, 5, 5); // Fills square
	
	
		renderMinimapGrid();
}

var grid_rows = terrain.get.getNumberQuadrantRows;

/*
rows/columns always the same
*/
function renderMinimapGrid(){

	var line_width = canvas_width;
	
	var grid_start_x = 0;
	var grid_start_y = 0;
	
	var grid_end_x = canvas_width;
	var grid_end_y = 0;	

	for(var y=0; y<grid_rows+1; y++){
		gui_context.beginPath();
		gui_context.moveTo(grid_start_x, grid_start_y);
		gui_context.lineTo(grid_end_x, grid_end_y);
		gui_context.lineWidth = 1;
		gui_context.strokeStyle = 'rgb(47, 161, 214)';
		gui_context.stroke();
	
		grid_start_y += canvas_boundary_mapped;
		grid_end_y += canvas_boundary_mapped;
	}

	// Reset values
	grid_start_y = 0;
	grid_end_y = canvas_width;
	grid_end_x = 0;
	
	for(var x=0; x<grid_rows+1; x++){
		gui_context.beginPath();
		gui_context.moveTo(grid_start_x, grid_start_y);
		gui_context.lineTo(grid_end_x, grid_end_y);
		gui_context.lineWidth = 1;
		gui_context.strokeStyle = 'rgb(47, 161, 214)';
		gui_context.stroke();
	
		grid_start_x += canvas_boundary_mapped;
		grid_end_x += canvas_boundary_mapped;
	}

}


/*
Waits 1 second before starting the scene,
This allows textures to load, avoiding WebGL texture errors
*/
setTimeout(
	function(){
		setup();  
	}, 1000
);

</script>

</body>
</html>